ðŸ“˜ SPRING & SPRING BOOT NOTES

------------------------------------------------------------
1. SETUP
------------------------------------------------------------
- Create the project in IntelliJ.
- Go to Maven Repository, select Spring Context, copy the Maven dependency and paste into the pom.xml file.

XML CONFIGURATION:
We have to create a folder in the main folder, then create the file of any name.
Then in the app file:
    ApplicationContext context = new ClassPathXmlApplicationContext("xmlfilename.xml");

------------------------------------------------------------
2. SPRING
------------------------------------------------------------
- Spring is the dependency injection core of Spring (Inversion of Control means Spring takes care of object creation and lifecycle).
- Spring Boot is a project of Spring, it has convention over configuration, embedded server, custom API.
- API methods: GET, POST, PUT, DELETE.
- Spring Data JPA (Java Persistence API):
    We can set what classes to create objects using XML.
- JVM has heap memory, Spring creates an extra container in the heap memory (IoC container type: ApplicationContext).

@Autowired
className objname
(Automatically injects dependencies: field injection, constructor injection, setter injection.)

SPRING MVC:
- Controller: Receives client request.
- Service: Business logic.
- Repository: Interacts with DB.

Bean initialization in XML:
<bean> is used for object creation in XML.

SYNTAX:
<beans>
    <bean id="id_name" class="location-of class file"></bean>
</beans>

Getting bean in code:
class_name object = (class_name) context.getBean(id_name);

------------------------------------------------------------
3. SETTER INJECTION
------------------------------------------------------------
Using setter method (getter/setter).

SYNTAX:
<beans>
    <bean id="id_name" class="location-of class file">
        <property name="name_variable" value="value"/>
    </bean>
</beans>

------------------------------------------------------------
4. TIGHT COUPLING EXAMPLE
------------------------------------------------------------
package org.example;

class student {
    private int age;
    private Pan pan;
    public Pan getPan() { return pan; }
    public void setPan(Pan pan) { this.pan = pan; }
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
    public void show() { System.out.println("Student"); }
}

package org.example;

public class Pan {
    public Pan() { System.out.println("Pan is created"); }
    void writeExam() { System.out.println("Writing in pen"); }
}

package org.example;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("Springxml.xml");
        student stobj = (student) context.getBean("st1");
        stobj.getPan().writeExam();
    }
}

XML:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="st1" class="org.example.student">
        <property name="age" value="20"/>
        <property name="pan" ref="pan1"/>
    </bean>

    <bean id="pan1" class="org.example.Pan"/>
</beans>

------------------------------------------------------------
5. LOOSE COUPLING VS TIGHT COUPLING
------------------------------------------------------------
- Loose coupling: less dependency.
- Tight coupling: high dependency.

------------------------------------------------------------
6. AUTOWIRING
------------------------------------------------------------
Autowiring automatically assigns properties.

BY NAME:
<bean id='st1' class='org.example.student' autowire="byName"></bean> 
<bean id='writer' class='org.example.Pen'></bean>

BY TYPE:
<bean id="st1" class="org.example.student">
    <property name="age" value="20"/>
    <property name="pan" ref="writer"/>
</bean>

<bean id='st1' class='org.example.student' autowire="byType"></bean> 
<bean id='writer' class='org.example.Pen' primary=true></bean>
<bean id='Pen' class='org.example.Pen'></bean>

------------------------------------------------------------
7. CONSTRUCTOR INJECTION
------------------------------------------------------------
We use parameter constructor (all-args-constructor, no-arg-constructor).

Java-based configuration example:
@Bean
public student Student() {
    return new student();
}

ApplicationContext context = new AnnotationConfigApplicationContext(Configfile.class);
Student st = context.getBean(student.class);

Giving bean a name:
@Bean(name = "st")
public student Student(@Autowired writer write) {
    student Student = new student();
    Student.setAge(20);
    Student.setWrite(write);
    return Student;
}

Using Qualifier:
public student Student(@Qualifier("pencil") writer write) {
    student Student = new student();
    Student.setAge(20);
    Student.setWrite(write);
    return Student;
}

------------------------------------------------------------
8. STEREOTYPE ANNOTATIONS
------------------------------------------------------------
- @Component â†’ Class object managed by Spring.
- @ComponentScan("org.example") â†’ Scan package for components.
- @Primary, @Qualifier â†’ To resolve multiple bean conflicts.
- @Value â†’ Assign value to field.

------------------------------------------------------------
9. SPRINGBOOT
------------------------------------------------------------
- Convention over configuration.
- Embedded server.
- Stores objects in IoC container.
- Scope:
    - Singleton â†’ Same object reference (default).
    - Prototype â†’ Different objects.

------------------------------------------------------------
10. DEPENDENCY INJECTION TYPES
------------------------------------------------------------
- Field injection (@Autowired on field)
- Setter injection (@Autowired on setter)
- Loose coupling using interface.

------------------------------------------------------------
11. API
------------------------------------------------------------
- API: Application Programming Interface (RESTful API).
- Controller: Receives client request.
- Service: Business logic.
- Repository: DB interaction.

Start a Spring Boot project: https://start.spring.io

Example Controller:
@RestController
@GetMapping("/")
public String home() { return "Hello"; }

- Front Controller â†’ directs to controller.
- @Service â†’ marks service class.
- Jackson â†’ automatically converts objects to JSON.

@PathVariable â†’ get parameter value from API.
@RequestBody Map<String,Object> â†’ get request body.

------------------------------------------------------------
12. JPA ANNOTATIONS
------------------------------------------------------------
- @Entity
- @Table(name = "users")
- @Id
- @GeneratedValue(strategy = GenerationType.IDENTITY)
- @Column(nullable=false)

------------------------------------------------------------
13. SPRING DATA
------------------------------------------------------------
- JpaRepository â†’ SQL DB with pre-built queries.
- MongoRepository â†’ MongoDB with pre-built queries.

BeanFactory:
- Simplest container for creating & managing beans.

Repository:
- Extends JPA, ORM maps objects to tables.
- ORM tools: Hibernate, SQLJPA, EclipseLink.

jpa.show = true â†’ shows SQL queries executed.

POJOs â†’ Plain Old Java Objects.

Native Query:
@Query(nativeQuery = true, value = "SQL query here")

------------------------------------------------------------
14. HTTP STATUS CODES
------------------------------------------------------------
- Informational: 100-199
- Success: 200-299
- Redirection: 300-399
- Client Error: 400-499
- Server Error: 500-599

------------------------------------------------------------
15. FRONTEND & SPRINGBOOT
------------------------------------------------------------
- Use @CrossOrigin(origin="frontend link") for connecting frontend.

------------------------------------------------------------
16. SERVLET
------------------------------------------------------------
- Servlet is a Java program running on a server.
- Handles client requests and responses.
- Server-side only.

Servlet Workflow:
1. Client sends request.
2. Web server checks for data, if not present, passes to web container.
3. Web container connects to servlet (configured in web.xml or with @WebServlet).
4. Servlet processes and generates output.
5. Web server sends output to client.

---------------------------------
17. Spring Bean Scopes (Detailed)
---------------------------------
Spring supports multiple bean scopes:

1. singleton â†’ One bean instance per Spring IoC container (default).
2. prototype â†’ A new bean instance is created every time it is requested.
3. request â†’ One bean instance per HTTP request (valid in web-aware Spring contexts).
4. session â†’ One bean instance per HTTP session.
5. application â†’ One bean instance per ServletContext.
6. websocket â†’ One bean instance per WebSocket session.

Annotations:
@Scope("singleton")
@Scope("prototype")

---------------------------------

18. Spring Boot Annotations (Common)
------------------------------------
1. @SpringBootApplication â†’ Combines @Configuration, @EnableAutoConfiguration, and @ComponentScan.
2. @EnableScheduling â†’ Enables scheduling with @Scheduled.
3. @EnableCaching â†’ Enables caching support with @Cacheable and related annotations.
4. @RestControllerAdvice â†’ Used for global exception handling in REST APIs.
5. @Transactional â†’ Marks a method or class for transaction management.

---------------------------------

19. Spring Boot Application Properties
--------------------------------------
Common configuration in application.properties or application.yml:

Example:
server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/db
spring.datasource.username=root
spring.datasource.password=pass
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

---------------------------------

20. Lifecycle of a Spring Bean
------------------------------
1. Bean is instantiated.
2. Dependencies are injected (populate properties).
3. BeanNameAware and BeanFactoryAware callbacks are called (if implemented).
4. @PostConstruct methods are executed.
5. Bean is ready for use.
6. On context shutdown, @PreDestroy methods are executed.

---------------------------------

21. Exception Handling in Spring Boot
-------------------------------------
1. @ExceptionHandler â†’ Handles specific exceptions in a controller.
2. @ControllerAdvice / @RestControllerAdvice â†’ Handles exceptions globally.
3. ResponseEntity â†’ Used to return a custom HTTP status and body.

Example:
@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<String> handleNotFound(ResourceNotFoundException ex) {
    return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
}

---------------------------------

22. Spring Boot Profiles
------------------------
Profiles allow environment-specific configurations.

application.properties:
spring.profiles.active=dev

Example usage:
@Profile("dev")
@Component
public class DevBean {
    // development-specific logic
}

---------------------------------

23. Testing in Spring Boot
--------------------------
1. @SpringBootTest â†’ Loads the full application context for integration tests.
2. @WebMvcTest â†’ Loads only the controller layer for testing.
3. MockMvc â†’ Allows performing mock HTTP requests in tests.

Example:
@Autowired
private MockMvc mockMvc;

@Test
public void testGet() throws Exception {
    mockMvc.perform(get("/api/test"))
           .andExpect(status().isOk());
}

---------------------------------

24. Security Basics in Spring Boot
----------------------------------
1. Spring Security can handle both JWT and session-based authentication.
2. @EnableWebSecurity â†’ Enables custom security configuration.
3. Common filters:
   - Authentication filter â†’ Validates user credentials or tokens.
   - Authorization filter â†’ Checks user permissions.
4. Password encoding: BCryptPasswordEncoder for hashing passwords.
5. Role-based access: @PreAuthorize, @Secured annotations.

Example:
@PreAuthorize("hasRole('ADMIN')")
public void adminOnlyMethod() {
    // Admin logic
}


Connection pool-> It have the connection between the server and db with needed requirements .

H2-> H2 is the database for stored the data in the tables in structure in tempory because when the start application it created again.
SpringBoot have the front controller -> because the if multiple controller have means  without front controller we have to create the multiple servlet that's while we use the front controller but when use SpringBoot it have default we don't create it;
dispatch servlet will Receive the client request and it will send to particular controller it decide that controller using some set of configurations